import chess
import chess.pgn
import pandas as pd
import matplotlib.pyplot as plt
import os, sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import plotting_helper


def extractResultData(pgnPath: str) -> pd.DataFrame:
    keys = ['White', 'Black', 'WhiteElo', 'BlackElo', 'Date', 'Event', 'Result']
    data = dict()
    for key in keys:
        data[key] = list()

    with open(pgnPath, 'r') as pgn:
        while game := chess.pgn.read_game(pgn):
            for key in keys:
                if key in game.headers.keys():
                    if 'Elo' in key:
                        data[key].append(int(game.headers[key]))
                    else:
                        data[key].append(game.headers[key])
                else:
                    data[key].append(None)

    df = pd.DataFrame(data)
    return df


def getResultsByRating(df: pd.DataFrame, rating: int, white: bool, offset: int = 10, oppRatingGroupWidth: int = 0) -> dict:
    """
    This function gets the result for the given rating against all other ratings
    df: pd.DataFrame
        The data extracted by extractResultData
    rating: int
        The rating of the players to look at
    white: bool
        If the games are from White's or Black's perspective
    offset: int
        Offset for a range of ratings
    """
    data = dict()
    if white:
        color = 'White'
        oppColor = 'Black'
    else:
        color = 'Black'
        oppColor = 'White'
    
    for i, row in df.iterrows():
        if row['WhiteElo'] is None or row['BlackElo'] is None:
            continue
        if rating-offset <= row[f'{color}Elo'] <= rating+offset:
            r = row['Result']
            if r == '1-0':
                rIndex = 0
            elif r == '1/2-1/2':
                rIndex = 1
            elif r == '0-1':
                rIndex = 2
            else:
                continue
            if not white:
                rIndex = 2-rIndex

            oppElo = row[f'{oppColor}Elo']
            if oppElo in data:
                data[oppElo][rIndex] += 1
                data[oppElo][3] += 1
            else:
                data[oppElo] = [0, 0, 0, 1]
                data[oppElo][rIndex] += 1

    if oppRatingGroupWidth > 0:
        minRating = int(min(data.keys()))
        minRating -= minRating%oppRatingGroupWidth
        ratingGroups = [r for r in range(minRating, int(max(data.keys()))+oppRatingGroupWidth, oppRatingGroupWidth)]
        groupedData = dict()
        for k, v in data.items():
            for i in range(len(ratingGroups)):
                if ratingGroups[i] <= k < ratingGroups[i+1]:
                    r = ratingGroups[i]
                    break
            if r in groupedData:
                for i in range(len(v)):
                    groupedData[r][i] += v[i]
            else:
                groupedData[r] = v

        data = groupedData

    avgData = dict()
    for k, v in data.items():
        avgData[k] = [round(v[i]/v[3], 3) for i in range(3)]
    return dict(sorted(avgData.items()))


def plotResultData(data: dict, filename: str = None):
    plotData = dict()
    for k, v in data.items():
        plotData[k] = v[0] + 0.5*v[1]

    plotting_helper.plotScatterPlot([list(plotData.keys())], [list(plotData.values())], 'Opponent rating', 'Score', 'Score for 2700 players depending on opponent rating', refFunction=eloFormula2, filename=filename)


def eloFormula(playerRating: int, oppRating: int) -> float:
    return 1 / (1 + 10**((oppRating-playerRating)/400))
    

def eloFormula2(oppRating: int) -> float:
    return 1 / (1 + 10**((oppRating-2700)/400))
    

if __name__ == '__main__':
    pgn = '../resources/2500+gamesUTF8.pgn'
    # df = extractResultData(pgn)
    # print(df)
    # df.to_pickle('../out/all2500games.pkl')
    df = pd.read_pickle('../out/all2500games.pkl')
    white = getResultsByRating(df, 2700, True, oppRatingGroupWidth=10)
    black = getResultsByRating(df, 2700, False, oppRatingGroupWidth=10)
    # plotResultData(white)
    # plotResultData(black)

    """
    wPlot = dict()
    for k, v in white.items():
        wPlot[k] = v[0] + v[1]*0.5
    bPlot = dict()
    for k, v in black.items():
        bPlot[k] = v[0] + v[1]*0.5
    
    xValues = [list(wPlot.keys()), list(bPlot.keys())]
    yValues = [list(wPlot.values()), list(bPlot.values())]
    plotting_helper.plotScatterPlot(xValues, yValues, 'Opponent rating', 'Score', 'Score for 2700 players with white and black against various ratings', refFunction=eloFormula2, scatterColors=plotting_helper.getColors(['orange', 'black']), legend=['Score with white', 'Score with black', 'Score by the Elo formula'], filename='../out/2700Score.png')
    """

    wWins = [v[0] for v in white.values()]
    wDraws = [v[1] for v in white.values()]
    wLosses = [v[2] for v in white.values()]
    bWins = [v[0] for v in black.values()]
    bDraws = [v[1] for v in black.values()]
    bLosses = [v[2] for v in black.values()]
    plotting_helper.plotLineChart([white.keys(), white.keys(), white.keys(), black.keys(), black.keys(), black.keys()], [wWins, wDraws, wLosses, bWins, bDraws, bLosses], 'Opponent rating', 'Relative number of games', 'WDL by rating', ['White wins', 'White draws', 'White losses', 'Black wins', 'Black draws', 'Black losses'], colors=plotting_helper.getColors(['purple', 'yellow', 'lightred', 'violet', 'orange', 'red']))
